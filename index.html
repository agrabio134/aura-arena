<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aura Orb 2D Battle Arena</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link href="/output.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script type="module">
    import { initializeFirebase } from './firebase.js';

    const API_URL = "https://graphql.tradeport.xyz/";
    const HEADERS = {
      "x-api-user": "auraonsui",
      "x-api-key": "dwHwieW.36f7a5bb7b7e7fd606a247414ccf158c",
      "Content-Type": "application/json"
    };
    const COLLECTION_ID = "ac33ae15-5c16-4d3b-b92a-2dde11e1346b";

    let db;
    let gameStarted = false;
    let countdown = 0;
    let startGameTriggered = false;
    let flashEffect = { timer: 0, alpha: 0 };

    initializeFirebase().then(firebaseDb => {
      db = firebaseDb;
      window.firebaseDb = db;
      console.log("Firebase initialized for game");
      if (!db) {
        Swal.fire({
          title: 'Error',
          text: 'Failed to initialize Firebase. Please check your connection.',
          icon: 'error',
          background: '#1a1a1a',
          color: '#ffffff',
          confirmButtonColor: '#4a5568'
        });
        document.getElementById('orb-count').textContent = "Error: Firebase not initialized";
      } else {
        listenForGameStart();
      }
    }).catch(error => {
      console.error("Firebase initialization error:", error);
      Swal.fire({
        title: 'Error',
        text: `Failed to initialize Firebase: ${error.message}.`,
        icon: 'error',
        background: '#1a1a1a',
        color: '#ffffff',
        confirmButtonColor: '#4a5568'
      });
    });

    async function listenForGameStart() {
      try {
        const { doc, onSnapshot } = await import('https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js');
        onSnapshot(doc(db, 'game_control', 'start'), (docSnapshot) => {
          if (docSnapshot.exists() && docSnapshot.data().start && !gameStarted) {
            startCountdown();
          }
        }, (error) => {
          console.error("Error listening for game start:", error);
          Swal.fire({
            title: 'Error',
            text: `Failed to listen for game start: ${error.message}.`,
            icon: 'error',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568'
          });
        });
      } catch (e) {
        console.error("Error setting up game start listener:", e);
      }
    }

    function startCountdown() {
      countdown = 5;
      startGameTriggered = false;
      const countdownInterval = setInterval(() => {
        document.getElementById('orb-count').textContent = `Starting in ${countdown}...`;
        countdown--;
        if (countdown < 0) {
          clearInterval(countdownInterval);
          startGameTriggered = true;
          document.getElementById('orb-count').textContent = "Loading orbs...";
        }
      }, 1000);
    }

    const traits = {
      "Core Color": [        { value: "Neon Blue", rarity: 0.4651, hex: "#00B7EB", rgb: [0, 183, 235], evasion: 0 },
        { value: "Cosmic Purple", rarity: 0.2326, hex: "#800080", rgb: [128, 0, 128], evasion: 1 },
        { value: "Crimson Glow", rarity: 0.1860, hex: "#DC143C", rgb: [220, 20, 60], evasion: 2 },
        { value: "Radiant Gold", rarity: 0.0930, hex: "#FFD700", rgb: [255, 215, 0], evasion: 3 },
        { value: "Prismatic Iridescence", rarity: 0.0233, hex: "#FFD700", rgb: [255, 215, 0], evasion: 5 }
      ],
      "Aura Effect": [        { value: "Surge", rarity: 0.3256, speed: 25, attack: 0, defense: 0, crowd_control: 0, evasion: 0, description: "Dashes with anime-style speed burst" },        { value: "Scape", rarity: 0.1395, speed: 0, attack: 0, defense: 0, evasion: 25, description: "Teleports to dodge like an anime ninja" },        { value: "Buff", rarity: 0.0930, speed: 0, attack: 0, defense: 0, xp_gain: 10, description: "Boosts nearby allies' attack" },        { value: "Split", rarity: 0.0698, speed: 15, attack: 0, defense: -5, positioning: 10, description: "Splits for tactical positioning" },        { value: "Absorb", rarity: 0.0233, speed: 0, attack: 20, defense: 0, description: "Fires energy blasts" },        { value: "Shield", rarity: 0.0930, speed: 0, attack: 0, defense: 20, description: "Creates a protective barrier" },        { value: "Pulse", rarity: 0.0930, speed: 0, attack: 10, defense: 0, crowd_control: 15, description: "Emits a zoning AoE pulse" },        { value: "Stealth", rarity: 0.0465, speed: 0, attack: -5, defense: 0, evasion: 20, description: "Fades like a stealthy anime character" },        { value: "Overcharge", rarity: 0.0465, speed: 0, attack: 30, defense: 0, description: "Unleashes a powerful laser beam" },        { value: "Singularity", rarity: 0.0698, speed: 0, attack: 5, defense: 0, crowd_control: 20, description: "Pulls enemies into a zoning vortex" }      ],
      "Skin": [        { value: "No Skin", rarity: 0.3256, defense: 0 },        { value: "Metallic", rarity: 0.3023, defense: 1 },        { value: "Nebula", rarity: 0.1395, defense: 2 },        { value: "Crystal", rarity: 0.1163, defense: 2 },        { value: "Holographic", rarity: 0.1163, defense: 3 }      ],
      "Flag": [        { value: "No Flag", rarity: 0.7442, country_code: null, morale: 0, battleCry: null },        { value: "Argentina", rarity: 0.0233, country_code: "AR", morale: 5, battleCry: "VAMOS!" },        { value: "Indonesia", rarity: 0.0233, country_code: "ID", morale: 5, battleCry: "JAYA!" },        { value: "Israel", rarity: 0.0233, country_code: "IL", morale: 5, battleCry: "SHALOM!" },        { value: "Japan", rarity: 0.0233, country_code: "JP", morale: 5, battleCry: "BANZAI!" },        { value: "Morocco", rarity: 0.0233, country_code: "MA", morale: 5, battleCry: "ZAHRA!" },        { value: "Norway", rarity: 0.0233, country_code: "NO", morale: 5, battleCry: "SKÅL!" },        { value: "Pakistan", rarity: 0.0233, country_code: "PK", morale: 5, battleCry: "ZINDABAD!" },        { value: "Qatar", rarity: 0.0233, country_code: "QA", morale: 5, battleCry: "MAJID!" },        { value: "United Kingdom", rarity: 0.0233, country_code: "GB", morale: 5, battleCry: "GOD SAVE!" },        { value: "Ethiopia", rarity: 0.0465, country_code: "ET", morale: 5, battleCry: "AMLAK!" }      ],
      "Rarity": [        { value: "Common", rarity: 0.4651, cooldownBase: 6 },        { value: "Uncommon", rarity: 0.1628, cooldownBase: 5.5 },        { value: "Rare", rarity: 0.0930, cooldownBase: 5 },        { value: "Epic", rarity: 0.2093, cooldownBase: 4.5 },        { value: "Legendary", rarity: 0.0698, cooldownBase: 4 }      ],
      "Special Modifier": [        { value: "None", rarity: 0.5116, attack_bonus: 0, xp_bonus: 0 },        { value: "XP Boost", rarity: 0.1163, attack_bonus: 0, xp_bonus: 5 },        { value: "Aura Charge", rarity: 0.2558, attack_bonus: 5, xp_bonus: 0 },        { value: "Holographic Sheen", rarity: 0.0930, attack_bonus: 7, xp_bonus: 0 },        { value: "Game Master Mark", rarity: 0.0233, attack_bonus: 10, xp_bonus: 0 }      ]
    };

    let orbs = [];
    let allNFTs = [];
    let particles = [];
    let projectiles = [];
    let cameraShake = { timer: 0, magnitude: 0, x: 0, y: 0 };
    let gameOver = false;

    async function fetchAllNFTs() {
      let nfts = [];
      let offset = 0;
      const limit = 50;
      let totalCount = await fetchTotalNFTCount();
      if (totalCount === null) {
        console.error("Failed to fetch total NFT count. Assuming 50 as fallback.");
        totalCount = 50;
      }
      console.log(`Total unlisted NFTs available: ${totalCount}`);

      while (nfts.length < totalCount) {
        const query = `
          query fetchCollectionItems($where: nfts_bool_exp!, $order_by: [nfts_order_by!], $offset: Int, $limit: Int!) {
            sui {
              nfts(where: $where, order_by: $order_by, offset: $offset, limit: $limit) {
                id
                token_id
                token_id_index
                name
                media_url
                media_type
                ranking
                owner
                delegated_owner
                chain_state
                lastSale: actions(
                  where: {type: {_in: ["buy", "accept-collection-bid", "accept-bid"]}}
                  order_by: {block_time: desc}
                  limit: 1
                ) {
                  price
                  price_coin
                }
                contract {
                  commission: default_commission { 
                    key
                    market_fee
                    market_name
                    royalty
                    is_custodial
                  }
                }
                attributes {
                  type
                  value
                }
              }
            }
          }
        `;
        const variables = {
          where: { 
            collection_id: { _eq: COLLECTION_ID }
          },
          order_by: [{ token_id: "asc" }, { ranking: "asc" }],
          offset,
          limit
        };

        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: HEADERS,
            body: JSON.stringify({ query, variables })
          });
          console.log(`API Response Status (offset ${offset}):`, response.status);
          const result = await response.json();
          console.log(`API Response (offset ${offset}):`, JSON.stringify(result, null, 2));
          if (result.errors) {
            console.error(`GraphQL Errors: ${result.errors.map(e => e.message).join(', ')}`);
            Swal.fire({
              title: 'Error',
              text: `GraphQL Errors: ${result.errors.map(e => e.message).join(', ')}`,
              icon: 'error',
              background: '#1a1a1a',
              color: '#ffffff',
              confirmButtonColor: '#4a5568'
            });
            break;
          }
          const fetchedNFTs = result.data.sui.nfts || [];
          console.log(`Fetched ${fetchedNFTs.length} NFTs in batch (offset: ${offset}, total: ${nfts.length + fetchedNFTs.length}/${totalCount})`);
          nfts.push(...fetchedNFTs);
          if (fetchedNFTs.length === 0) {
            console.log("No more NFTs to fetch.");
            break;
          }
          offset += fetchedNFTs.length;
          if (nfts.length >= totalCount) {
            console.log(`Reached total count of ${totalCount} NFTs.`);
            break;
          }
          await new Promise(resolve => setTimeout(resolve, 1000));
        } catch (e) {
          console.error(`Fetch NFTs Error (offset ${offset}): ${e.message}`);
          Swal.fire({
            title: 'Error',
            text: `Failed to fetch NFTs: ${e.message}. Retrying after delay...`,
            icon: 'error',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568'
          });
          await new Promise(resolve => setTimeout(resolve, 2000));
          continue;
        }
      }

      console.log(`Total Fetched ${nfts.length} NFTs`);
      if (nfts.length < totalCount) {
        Swal.fire({
          title: 'Warning',
          text: `Fetched only ${nfts.length} of ${totalCount} expected NFTs. Possible API limitation or data issue.`,
          icon: 'warning',
          background: '#1a1a1a',
          color: '#ffffff',
          confirmButtonColor: '#4a5568'
        });
      }
      return nfts;
    }

    async function fetchTotalNFTCount() {
      const countQuery = `
        query fetchCollectionCount($where: nfts_bool_exp!) {
          sui {
            nfts_aggregate(where: $where) {
              aggregate {
                count
              }
            }
          }
        }
      `;
      const countVariables = {
        where: { 
          collection_id: { _eq: COLLECTION_ID },
          _not: { listed: { _eq: true } }
        }
      };
      try {
        const countResponse = await fetch(API_URL, {
          method: 'POST',
          headers: HEADERS,
          body: JSON.stringify({ query: countQuery, variables: countVariables })
        });
        const countResult = await countResponse.json();
        if (countResult.errors) {
          console.error(`GraphQL Count Errors: ${countResult.errors.map(e => e.message).join(', ')}`);
          return null;
        }
        const totalCount = countResult.data.sui.nfts_aggregate.aggregate.count;
        console.log('Total Unlisted NFTs in collection:', totalCount);
        return totalCount;
      } catch (e) {
        console.error(`Fetch Total NFT Count Error: ${e.message}`);
        Swal.fire({
          title: 'Error',
          text: `Failed to fetch total NFT count: ${e.message}.`,
          icon: 'error',
          background: '#1a1a1a',
          color: '#ffffff',
          confirmButtonColor: '#4a5568'
        });
        return null;
      }
    }

    async function fetchNFTDetails(nftId) {
      const query = `
        query fetchNftAttributes($nftId: uuid!) {
          sui {
            nfts(where: { id: { _eq: $nftId } }) {
              name
              token_id
              media_url
              ranking
              owner
              attributes {
                type
                value
                rarity
              }
            }
          }
        }
      `;
      const variables = { nftId };
      try {
        const response = await fetch(API_URL, {
          method: 'POST',
          headers: HEADERS,
          body: JSON.stringify({ query, variables })
        });
        const result = await response.json();
        if (result.errors) {
          console.error(`GraphQL Errors for ${nftId}: ${result.errors.map(e => e.message).join(', ')}`);
          return null;
        }
        if (!result.data.sui.nfts[0]) {
          console.warn(`No NFT found for nftId: ${nftId}`);
          return null;
        }
        return result.data.sui.nfts[0];
      } catch (e) {
        console.error(`Fetch NFT Details Error for ${nftId}: ${e.message}`);
        return null;
      }
    }

    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      return [r, g, b];
    }

    function validateRgb(rgb) {
      return Array.isArray(rgb) && rgb.length === 3 && rgb.every(v => typeof v === 'number' && v >= 0 && v <= 255) ? rgb : [0, 183, 235];
    }

    function calculateStats(attributes, ranking, name, owner) {
      const attributeMap = {};
      attributes.forEach(attr => {
        attributeMap[attr.type] = { value: attr.value, rarity: attr.rarity };
      });

      const defaultAttributes = {
        "Core Color": { value: "Neon Blue", rarity: 0.4651 },
        "Aura Effect": { value: "Surge", rarity: 0.3256 },
        "Skin": { value: "No Skin", rarity: 0.3256 },
        "Flag": { value: "No Flag", rarity: 0.7442 },
        "Rarity": { value: "Common", rarity: 0.4651 },
        "Special Modifier": { value: "None", rarity: 0.5116 }
      };

      const effectiveAttributes = { ...defaultAttributes, ...attributeMap };

      const rarity = traits["Rarity"].find(t => t.value === effectiveAttributes.Rarity.value) || traits["Rarity"][0];
      const coreColor = traits["Core Color"].find(t => t.value === effectiveAttributes["Core Color"].value) || traits["Core Color"][0];
      const auraEffect = traits["Aura Effect"].find(t => t.value === effectiveAttributes["Aura Effect"].value) || traits["Aura Effect"][0];
      const skin = traits["Skin"].find(t => t.value === effectiveAttributes.Skin.value) || traits["Skin"][0];
      const flag = traits["Flag"].find(t => t.value === effectiveAttributes.Flag.value) || traits["Flag"][0];
      const specialModifier = traits["Special Modifier"].find(t => t.value === effectiveAttributes["Special Modifier"].value) || traits["Special Modifier"][0];

      const isLongRange = ["Overcharge", "Absorb", "Pulse", "Singularity"].includes(auraEffect.value);
      const role = auraEffect.evasion >= 20 ? "Dodging" :
                   isLongRange ? "Long-Range" :
                   skin.defense >= 2 ? "Tank" :
                   rarity.cooldownBase <= 4.5 ? "Good" : "Bad";

      let baseHealth = 100 + (skin.defense || 0) * 5 + (ranking || 0) / 200 * (role === "Bad" ? 1.2 : role === "Tank" ? 0.9 : 1);
      let baseAttack = 10 + (auraEffect.attack || 0) * 0.7 + (specialModifier.attack_bonus || 0) * 0.8 * (role === "Bad" ? 1.2 : role === "Tank" ? 0.8 : 1);
      let baseDefense = 1 + (auraEffect.defense || 0) * 0.5 + (skin.defense || 0) * 0.5;
      let baseSpeed = (8 + (auraEffect.speed || 0)) * 0.8 * 1.1;

      if (name.toLowerCase() === "milly") {
        baseHealth *= 1.2;
        baseAttack *= 1.15;
        baseSpeed *= 1.1;
      }

      baseDefense *= (role === "Long-Range" ? 0.7 : 1);

      const stats = {
        health: baseHealth,
        maxHealth: baseHealth,
        attack: baseAttack,
        defense: baseDefense,
        speed: baseSpeed * (flag.morale > 0 ? 1.1 : 1),
        evasion: Math.min(0.15, (coreColor.evasion || 0) * 0.01 + (auraEffect.evasion || 0) / 200),
        crowdControl: (auraEffect.crowd_control || 0) / 100,
        morale: flag.morale || 0,
        xpGain: (auraEffect.xp_gain || 0) + (specialModifier.xp_bonus || 0),
        coreColor: coreColor.hex || "#00B7EB",
        coreRgb: coreColor.rgb || [0, 183, 235],
        auraEffect: auraEffect.value,
        skin: skin.value,
        rarity: rarity.value,
        specialModifier: specialModifier.value,
        role,
        attackRange: isLongRange ? 200 : 50,
        cooldownBase: rarity.cooldownBase || 6,
        owner: owner || "Unknown",
        hasFlag: flag.value !== "No Flag",
        battleCry: flag.battleCry,
        flagShieldActive: flag.value !== "No Flag",
        flagShieldTimer: flag.value !== "No Flag" ? 40 : 0,
        flagShieldCooldown: 0,
        rallyTimer: 0
      };

      stats.cooldown = Math.max(4, Math.min(6, stats.cooldownBase * (role === "Bad" ? 0.9 : 1))) * (stats.hasFlag ? 0.8 : 1);
      if (stats.health <= 0) {
        stats.health = stats.maxHealth = 100;
        console.warn(`Adjusted health for ${name} to 100 due to invalid stats`);
      }
      return stats;
    }

    const sketch = (p) => {
      function getRandomCoreColor() {
        const colors = traits["Core Color"];
        const totalRarity = colors.reduce((sum, color) => sum + color.rarity, 0);
        let random = p.random(totalRarity);
        for (const color of colors) {
          random -= color.rarity;
          if (random <= 0) return { hex: color.hex, rgb: color.rgb };
        }
        return { hex: colors[0].hex, rgb: colors[0].rgb };
      }

      function convertMediaUrl(url) {
        if (!url) return null;
        if (url.startsWith('ipfs://')) {
          return url.replace('ipfs://', 'https://ipfs.io/ipfs/');
        } else if (url.startsWith('walrus://')) {
          return null;
        }
        return url;
      }

      async function loadOrbs() {
        console.log("Starting to load orbs...");
        document.getElementById('orb-count').textContent = "Loading orbs...";
        orbs = [];
        allNFTs = await fetchAllNFTs();
        if (allNFTs.length === 0) {
          console.error('No NFTs fetched. No orbs will be displayed.');
          Swal.fire({
            title: 'Error',
            text: 'Failed to fetch NFTs. Please check your API credentials or network connection.',
            icon: 'error',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568'
          });
          document.getElementById('orb-count').textContent = "Failed to load NFTs";
          return false;
        }
        let skippedCount = 0;
        const promises = allNFTs.map(async (nft, index) => {
          const details = nft;
          if (!details) {
            console.warn(`Skipping ${nft.name} due to null details`);
            skippedCount++;
            return null;
          }
          const stats = calculateStats(details.attributes || [], details.ranking || 0, details.name, details.owner);
          let image = null;
          try {
            const imageUrl = convertMediaUrl(details.media_url);
            if (imageUrl) {
              image = await p.loadImage(imageUrl);
            }
          } catch (e) {
            console.warn(`Failed to load image for ${nft.name}: ${e.message}`);
          }
          const orb = {
            id: nft.id,
            name: nft.name,
            ...stats,
            image,
            x: p.random(100, 1100),
            y: p.random(100, 700),
            radius: 15 + (traits["Rarity"].findIndex(r => r.value === stats.rarity) + 1) * 3,
            skillCooldown: 0,
            shieldActive: false,
            chargeActive: false,
            surgeActive: false,
            gmmActive: false,
            effectTimer: 0,
            skillScale: 1,
            targetX: null,
            targetY: null,
            targetResetFrame: 0,
            spawnProgress: 0,
            shakeTimer: 0,
            shakeMagnitude: 0,
            rotation: 0,
            trail: [],
            swordSlash: null,
            attackEffectTimer: 0,
            battleCryTimer: 0
          };
          return orb;
        });
        orbs = (await Promise.all(promises)).filter(orb => orb !== null);
        console.log(`Skipped ${skippedCount} NFTs due to null details`);
        if (orbs.length === 0) {
          console.error('No valid orbs created. Check NFT data and API.');
          Swal.fire({
            title: 'Error',
            text: 'No valid NFTs could be loaded. Please check your API or NFT data.',
            icon: 'error',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568'
          });
          document.getElementById('orb-count').textContent = "No valid NFTs loaded";
          return false;
        }
        console.log(`Loaded ${orbs.length} orbs successfully`);
        orbs.forEach((orb, i) => setTimeout(() => orb.spawnProgress = 1, i * 100));
        updateOrbStats();
        document.getElementById('orb-count').textContent = `Active Orbs: ${orbs.filter(o => o.health > 0).length}`;
        return true;
      }

      p.preload = async () => {};

      p.setup = () => {
        try {
          p.createCanvas(1200, 800).parent('canvas-container');
          p.frameRate(40);
          p.background(20, 30, 50);
          document.getElementById('orb-count').textContent = "Waiting for game start...";
        } catch (e) {
          console.error(`Setup error: ${e.message}`);
          Swal.fire({
            title: 'Setup Error',
            text: `Failed to initialize game canvas: ${e.message}. Please refresh and try again.`,
            icon: 'error',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568'
          });
        }
      };

      p.draw = () => {
        try {
          p.push();
          p.background(20, 30, 50);
          if (!gameStarted) {
            p.fill(255);
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(24);
            p.text(countdown > 0 ? `Starting in ${countdown}...` : "Waiting for game start...", p.width / 2, p.height / 2);
            if (startGameTriggered && !gameStarted) {
              startGame();
            }
            p.pop();
            return;
          }
          if (cameraShake.timer > 0) {
            cameraShake.x = p.random(-cameraShake.magnitude, cameraShake.magnitude);
            cameraShake.y = p.random(-cameraShake.magnitude, cameraShake.magnitude);
            cameraShake.timer--;
            p.translate(cameraShake.x, cameraShake.y);
          } else {
            cameraShake.x = cameraShake.y = 0;
          }
          if (flashEffect.timer > 0) {
            p.fill(255, 255, 255, flashEffect.alpha);
            p.noStroke();
            p.rect(0, 0, p.width, p.height);
            flashEffect.alpha -= 25;
            flashEffect.timer--;
          }
          for (let i = 0; i < 20; i++) {
            p.fill(255, 255, 255, p.random(5, 20));
            p.noStroke();
            p.circle(p.random(p.width), p.random(p.height), p.random(2, 5));
          }
          particles = particles.filter(particle => particle.lifetime > 0);
          particles.forEach(particle => {
            try {
              p.fill(p.color(...validateRgb(particle.rgb), particle.alpha));
              p.noStroke();
              p.ellipse(particle.x, particle.y, particle.size, particle.size * 0.7);
              particle.x += particle.vx;
              particle.y += particle.vy;
              particle.lifetime -= 1;
              particle.alpha = p.max(0, particle.alpha - particle.fadeRate);
              particle.size *= 0.98;
            } catch (e) {
              console.error(`Error drawing particle: ${e.message}`);
            }
          });
          projectiles = projectiles.filter(proj => proj.lifetime > 0);
          projectiles.forEach(proj => {
            try {
              p.push();
              p.translate(proj.x, proj.y);
              p.rotate(p.atan2(proj.vy, proj.vx));
              if (proj.beamTimer && proj.beamTimer > 0) {
                p.stroke(255, 0, 0, 255 * (proj.beamTimer / 20));
                p.strokeWeight(4);
                p.line(0, 0, proj.target ? p.dist(proj.x, proj.y, proj.target.x, proj.target.y) : 200, 0);
                createParticle({ x: proj.x, y: proj.y }, '#ff0000', 4, 15, true);
                proj.beamTimer--;
              } else {
                p.fill(p.color(...validateRgb(proj.rgb), proj.alpha));
                p.noStroke();
                p.triangle(0, 0, -proj.size * 2, proj.size * 0.5, -proj.size * 2, -proj.size * 0.5);
                p.fill(p.color(...validateRgb(proj.rgb), proj.alpha * 0.5));
                p.ellipse(-proj.size * 1.5, 0, proj.size * 3, proj.size * 0.4);
                if (proj.isSummon) {
                  p.fill(p.color(...validateRgb(proj.rgb), proj.alpha * 0.3));
                  p.ellipse(-proj.size * 3, 0, proj.size * 4, proj.size * 0.2);
                }
              }
              p.pop();
              proj.x += proj.vx;
              proj.y += proj.vy;
              proj.lifetime -= 1;
              proj.alpha = p.max(0, proj.alpha - 8);
              if (proj.lifetime <= 0 && proj.target && proj.target.health > 0) {
                let damage = proj.damage / (1 + proj.target.defense / 10);
                if (proj.target.flagShieldActive && proj.target.flagShieldTimer > 0 && proj.target.flagShieldCooldown <= 0) {
                  let blocked = p.min(damage, 10);
                  damage -= blocked;
                  proj.target.flagShieldActive = false;
                  proj.target.flagShieldCooldown = 200;
                  createParticle(proj.target, '#00f', 10, 30, true);
                  triggerCameraShake(3, 8);
                } else if (proj.target.shieldActive) {
                  let blocked = p.min(damage, 10);
                  damage -= blocked;
                  proj.target.shieldActive = false;
                  createParticle(proj.target, '#00f', 10, 30, true);
                  triggerCameraShake(3, 8);
                }
                if (proj.orb.specialModifier === "Holographic Sheen") {
                  let reflect = p.round(damage * 0.05);
                  proj.orb.health = p.max(0, proj.orb.health - reflect);
                  createParticle(proj.orb, '#0ff', 6, 15);
                }
                proj.target.health = p.max(0, p.round(proj.target.health - damage));
                proj.target.shakeTimer = 10;
                proj.target.shakeMagnitude = damage / 4;
                proj.target.swordSlash = { angle: p.atan2(proj.vy, proj.vx), timer: 15, size: 30 };
                triggerCameraShake(4, 10);
                updateOrbStats();
                checkGameOver();
              }
            } catch (e) {
              console.error(`Error drawing projectile: ${e.message}`);
            }
          });
          orbs.forEach(orb => {
            if (orb.health <= 0) return;
            if (orb.flagShieldTimer > 0) {
              orb.flagShieldTimer--;
              if (orb.flagShieldTimer <= 0) {
                orb.flagShieldActive = false;
              }
            }
            if (orb.flagShieldCooldown > 0) {
              orb.flagShieldCooldown--;
              if (orb.flagShieldCooldown <= 0 && orb.hasFlag) {
                orb.flagShieldActive = true;
                orb.flagShieldTimer = 40;
              }
            }
            if (orb.effectTimer > 0) {
              orb.effectTimer--;
              if (orb.effectTimer <= 0 && orb.auraEffect === "Shield") {
                orb.shieldActive = false;
              }
            }
            if (orb.rallyTimer > 0) {
              orb.rallyTimer--;
            }
            moveOrb(orb);
            if (p.frameCount % 60 === 0) {
              orb.skillCooldown = p.max(0, orb.skillCooldown - 1);
              if (orb.skillCooldown === 0) useSkill(orb);
              orb.skillScale = orb.skillCooldown > 0 ? 0.7 : 1.5;
            }
            if (p.frameCount % 20 === 0) attack(orb);
            orb.rotation += 0.06 * (orb.role === "Dodging" ? 2.5 : 1);
            if (orb.swordSlash && orb.swordSlash.timer > 0) {
              orb.swordSlash.timer--;
            }
            if (orb.attackEffectTimer > 0) {
              orb.attackEffectTimer--;
            }
            if (orb.battleCryTimer > 0) {
              orb.battleCryTimer--;
            }
            drawOrb(orb);
            drawOrbLabels(orb);
          });
          document.getElementById('orb-count').textContent = `Active Orbs: ${orbs.filter(o => o.health > 0).length}`;
          p.pop();
        } catch (e) {
          console.error(`Draw loop error: ${e.message}`);
          Swal.fire({
            title: 'Game Error',
            text: `An error occurred in the game loop: ${e.message}. Please refresh and try again.`,
            icon: 'error',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568'
          });
        }
      };

      function triggerCameraShake(magnitude, duration) {
        cameraShake.magnitude = magnitude * 0.5;
        cameraShake.timer = duration;
      }

      function triggerFlashEffect() {
        flashEffect.timer = 10;
        flashEffect.alpha = 100;
      }

      async function checkGameOver() {
        const aliveOrbs = orbs.filter(o => o.health > 0);
        if (aliveOrbs.length === 1 && !gameOver) {
          gameOver = true;
          const winner = aliveOrbs[0];
          try {
            const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js');
            await addDoc(collection(window.firebaseDb, "winners"), {
              id: winner.id,
              name: winner.name,
              owner: winner.owner,
              role: winner.role,
              timestamp: serverTimestamp(),
              stats: {
                health: winner.health,
                attack: winner.attack,
                defense: winner.defense,
                speed: winner.speed,
                rarity: winner.rarity
              }
            });
            console.log("Winner saved to Firestore");
          } catch (e) {
            console.error("Error saving winner to Firestore:", e);
            Swal.fire({
              title: 'Error',
              text: 'Failed to save winner to Firestore. Please check your connection.',
              icon: 'error',
              background: '#1a1a1a',
              color: '#ffffff',
              confirmButtonColor: '#4a5568'
            });
          }
          Swal.fire({
            title: 'Victory!',
            html: `<strong>${winner.name}</strong> is the last orb standing!<br>Owner: ${winner.owner}`,
            icon: 'success',
            background: '#1a1a1a',
            color: '#ffffff',
            confirmButtonColor: '#4a5568',
            confirmButtonText: 'Awesome!'
          }).then(() => {
            gameStarted = false;
            startGameTriggered = false;
            document.getElementById('orb-count').textContent = "Waiting for game start...";
          });
        }
      }

      function moveOrb(orb) {
        if (orb.health <= 0) return;
        if (p.frameCount - orb.targetResetFrame > 100) {
          orb.targetX = null;
          orb.targetResetFrame = p.frameCount;
        }
        let target = findNearestEnemy(orb);
        if (!target) {
          orb.targetX = p.random(50, 1150);
          orb.targetY = p.random(50, 750);
        } else {
          if (!orb.targetX || p.dist(orb.x, orb.y, target.x, target.y) > orb.attackRange * 1.5) {
            orb.targetX = target.x + p.random(-50, 50);
            orb.targetY = target.y + p.random(-50, 50);
            orb.targetResetFrame = p.frameCount;
          }
        }
        let dx = orb.targetX - orb.x;
        let dy = orb.targetY - orb.y;
        let distance;
        try {
          distance = p.dist(orb.x, orb.y, orb.targetX, orb.targetY);
        } catch (e) {
          console.error(`Error calculating distance for ${orb.name}: ${e.message}`);
          return;
        }
        if (distance < 100) {
          orb.targetX = p.random(50, 1150);
          orb.targetY = p.random(50, 750);
          dx = orb.targetX - orb.x;
          dy = orb.targetY - orb.y;
          distance = p.dist(orb.x, orb.y, orb.targetX, orb.targetY);
        }
        let speed = orb.surgeActive ? orb.speed * 2.5 : orb.speed;
        if (orb.gmmActive) speed *= 1.3;
        if (orb.rallyTimer > 0 && orb.hasFlag) {
          if (orb.battleCry === "VAMOS!") speed *= 1.3; // Argentina
          if (orb.battleCry === "VORWÄRTS!") speed *= 1.5; // Germany
          if (orb.battleCry === "MAJID!") speed *= 1.1; // Qatar
        }
        let moveX = distance > 0 ? (dx / distance) * speed : 0;
        let moveY = distance > 0 ? (dy / distance) * speed : 0;
        if (orb.role === "Dodging" || (orb.rallyTimer > 0 && orb.battleCry === "SHALOM!")) {
          moveX += p.random(-6, 6);
          moveY += p.random(-6, 6);
        }
        if (orb.rallyTimer > 0 && orb.battleCry === "ZAHRA!") {
          moveX *= 0.8; // Morocco slow
          moveY *= 0.8;
        }
        orb.x = p.lerp(orb.x, orb.x + moveX, 0.4);
        orb.y = p.lerp(orb.y, orb.y + moveY, 0.4);
        orb.x = p.constrain(orb.x, orb.radius, p.width - orb.radius);
        orb.y = p.constrain(orb.y, orb.radius, p.height - orb.radius);
        orb.trail.push({ x: orb.x, y: orb.y, alpha: 120 });
        if (orb.trail.length > 12) orb.trail.shift();
      }

      function findNearestEnemy(orb) {
        let minDist = Infinity;
        let target = null;
        orbs.forEach(other => {
          if (other === orb || other.health <= 0) return;
          if (typeof other.x !== 'number' || typeof other.y !== 'number' || isNaN(other.x) || isNaN(other.y)) {
            console.warn(`Invalid coordinates for ${other.name}`);
            return;
          }
          let distance;
          try {
            distance = p.dist(orb.x, orb.y, other.x, other.y);
          } catch (e) {
            console.error(`Error in dist for ${orb.name} to ${other.name}: ${e.message}`);
            return;
          }
          if (distance < minDist && distance > 20) {
            minDist = distance;
            target = other;
          }
        });
        return target;
      }

      function useSkill(orb) {
        if (orb.health <= 0) return;
        orb.skillCooldown = orb.cooldown;
        orb.effectTimer = orb.auraEffect === "Shield" ? 40 : 60;
        orb.skillScale = 1.5;
        if (orb.hasFlag && orb.battleCry) {
          orb.battleCryTimer = 80;
          orb.rallyTimer = 40;
          triggerFlashEffect();
          triggerCameraShake(6, 12);
          if (orb.battleCry === "BANZAI!") { // Japan
            orbs.forEach(other => {
              if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 100) {
                let damage = 20 * orb.crowdControl;
                if (other.flagShieldActive && other.flagShieldTimer > 0 && other.flagShieldCooldown <= 0) {
                  let blocked = p.min(damage, 10);
                  damage -= blocked;
                  other.flagShieldActive = false;
                  other.flagShieldCooldown = 200;
                  createParticle(other, '#00f', 10, 30, true);
                } else if (other.shieldActive) {
                  let blocked = p.min(damage, 10);
                  damage -= blocked;
                  other.shieldActive = false;
                  createParticle(other, '#00f', 10, 30, true);
                }
                other.health = p.max(0, p.round(other.health - damage));
                other.shakeTimer = 10;
                other.shakeMagnitude = 3;
                createParticle(other, '#ff0000', 10, 30, true);
              }
            });
            for (let i = 0; i < 8; i++) {
              let angle = (i / 8) * p.TWO_PI;
              projectiles.push({
                x: orb.x,
                y: orb.y,
                target: null,
                orb,
                damage: 5,
                color: '#ff0000',
                rgb: [255, 0, 0],
                size: 6,
                lifetime: 40,
                alpha: 255,
                vx: Math.cos(angle) * 8,
                vy: Math.sin(angle) * 8,
                isSummon: true
              });
              createParticle(orb, '#ffffff', 8, 20, true);
            }
          } else if (orb.battleCry === "LABAN!") { // Philippines
            orbs.forEach(other => {
              if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 80) {
                other.attack += 5;
                other.speed *= 1.1;
                other.rallyTimer = 40;
                createParticle(other, '#FFD700', 8, 20, true);
              }
            });
            for (let i = 0; i < 3; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 8,
                  color: '#FFD700',
                  rgb: [255, 215, 0],
                  size: 7,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "CHARGE!!!") { // US
            let target = findNearestEnemy(orb);
            if (target) {
              projectiles.push({
                x: orb.x,
                y: orb.y,
                target,
                orb,
                damage: orb.attack * 2,
                color: '#0000FF',
                rgb: [0, 0, 255],
                size: 10,
                lifetime: 50,
                alpha: 255,
                vx: (target.x - orb.x) / 25,
                vy: (target.y - orb.y) / 25,
                isSummon: false
              });
            }
            for (let i = 0; i < 4; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 6,
                  color: '#0000FF',
                  rgb: [0, 0, 255],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "VAMOS!") { // Argentina
            orb.speed *= 1.3;
            orb.attack *= 1.1;
            for (let i = 0; i < 5; i++) {
              let angle = p.atan2(orb.targetY - orb.y, orb.targetX - orb.x) + (i - 2) * 0.2;
              projectiles.push({
                x: orb.x,
                y: orb.y,
                target: null,
                orb,
                damage: 5,
                color: '#C0C0C0',
                rgb: [192, 192, 192],
                size: 6,
                lifetime: 40,
                alpha: 255,
                vx: Math.cos(angle) * 8,
                vy: Math.sin(angle) * 8,
                isSummon: true
              });
            }
            createParticle(orb, '#C0C0C0', 10, 30, true);
          } else if (orb.battleCry === "JAYA!") { // Indonesia
            let target = findNearestEnemy(orb);
            if (target) {
              projectiles.push({
                x: orb.x,
                y: orb.y,
                target,
                orb,
                damage: 15 * orb.crowdControl,
                color: '#008000',
                rgb: [0, 128, 0],
                size: 8,
                lifetime: 50,
                alpha: 255,
                vx: (target.x - orb.x) / 20,
                vy: (target.y - orb.y) / 20,
                isSummon: false
              });
            }
            for (let i = 0; i < 4; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 6,
                  color: '#008000',
                  rgb: [0, 128, 0],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "SHALOM!") { // Israel
            orbs.forEach(other => {
              if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 80) {
                other.shieldActive = true;
                other.effectTimer = 40;
                createParticle(other, '#FFFFFF', 8, 20, true);
              }
            });
            for (let i = 0; i < 3; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 7,
                  color: '#FFFFFF',
                  rgb: [255, 255, 255],
                  size: 7,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "ZAHRA!") { // Morocco
            orbs.forEach(other => {
              if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 100) {
                other.rallyTimer = 40;
                createParticle(other, '#FFA500', 8, 20, true);
              }
            });
            for (let i = 0; i < 6; i++) {
              let angle = (i / 6) * p.TWO_PI;
              projectiles.push({
                x: orb.x,
                y: orb.y,
                target: null,
                orb,
                damage: 4,
                color: '#FFA500',
                rgb: [255, 165, 0],
                size: 5,
                lifetime: 40,
                alpha: 255,
                vx: Math.cos(angle) * 8,
                vy: Math.sin(angle) * 8,
                isSummon: true
              });
            }
          } else if (orb.battleCry === "SKÅL!") { // Norway
            orb.attack *= 1.15;
            orb.rallyTimer = 40;
            for (let i = 0; i < 4; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 6,
                  color: '#0000FF',
                  rgb: [0, 0, 255],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "ZINDABAD!") { // Pakistan
            let target = findNearestEnemy(orb);
            if (target) {
              let angle = p.atan2(target.y - orb.y, target.x - orb.x);
              projectiles.push({
                x: orb.x,
                y: orb.y,
                target,
                orb,
                damage: orb.attack * 1.5,
                color: '#008000',
                rgb: [0, 128, 0],
                size: 8,
                lifetime: 50,
                alpha: 255,
                vx: (target.x - orb.x) / 20 + p.random(-2, 2),
                vy: (target.y - orb.y) / 20 + p.random(-2, 2),
                isSummon: false
              });
            }
            for (let i = 0; i < 5; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 5,
                  color: '#008000',
                  rgb: [0, 128, 0],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "MAJID!") { // Qatar
            orbs.forEach(other => {
              if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 100) {
                let damage = 10 * orb.crowdControl;
                if (other.flagShieldActive && other.flagShieldTimer > 0 && other.flagShieldCooldown <= 0) {
                  let blocked = p.min(damage, 10);
                  damage -= blocked;
                  other.flagShieldActive = false;
                  other.flagShieldCooldown = 200;
                  createParticle(other, '#00f', 10, 30, true);
                } else if (other.shieldActive) {
                  let blocked = p.min(damage, 10);
                  damage -= blocked;
                  other.shieldActive = false;
                  createParticle(other, '#00f', 10, 30, true);
                }
                other.health = p.max(0, p.round(other.health - damage));
                other.shakeTimer = 10;
                other.shakeMagnitude = 3;
                createParticle(other, '#800080', 10, 30, true);
              }
            });
            orb.evasion = Math.min(0.15, orb.evasion + 0.1);
            orb.rallyTimer = 40;
            for (let i = 0; i < 4; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 6,
                  color: '#800080',
                  rgb: [128, 0, 128],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "GOD SAVE!") { // United Kingdom
            for (let i = 0; i < 3; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + (i - 1) * 0.3;
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: orb.attack * 0.8,
                  color: '#FF0000',
                  rgb: [255, 0, 0],
                  size: 7,
                  lifetime: 50,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: false
                });
              }
            }
            for (let i = 0; i < 4; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 6,
                  color: '#FF0000',
                  rgb: [255, 0, 0],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          } else if (orb.battleCry === "AMLAK!") { // Ethiopia
            orbs.forEach(other => {
              if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 80) {
                other.attack += 5;
                createParticle(other, '#8B4513', 8, 20, true);
              }
            });
            triggerCameraShake(3, 8);
            for (let i = 0; i < 5; i++) {
              let target = findNearestEnemy(orb);
              if (target) {
                let angle = p.atan2(target.y - orb.y, target.x - orb.x) + p.random(-0.1, 0.1);
                projectiles.push({
                  x: orb.x,
                  y: orb.y,
                  target,
                  orb,
                  damage: 5,
                  color: '#8B4513',
                  rgb: [139, 69, 19],
                  size: 6,
                  lifetime: 40,
                  alpha: 255,
                  vx: Math.cos(angle) * 8,
                  vy: Math.sin(angle) * 8,
                  isSummon: true
                });
              }
            }
          }
        }
        if (orb.auraEffect === "Shield") {
          orb.shieldActive = true;
          createParticle(orb, '#00f', 10, 40, true);
        } else if (orb.auraEffect === "Surge") {
          orb.surgeActive = true;
          setTimeout(() => orb.surgeActive = false, 1200);
          createParticle(orb, '#0ff', 8, 30, true);
          triggerCameraShake(5, 12);
        } else if (orb.auraEffect === "Singularity") {
          orbs.forEach(other => {
            if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 120) {
              other.x += (orb.x - other.x) * 0.25;
              other.y += (orb.y - other.y) * 0.25;
              createParticle(other, '#800080', 6, 25);
              triggerCameraShake(6, 14);
            }
          });
        } else if (orb.auraEffect === "Pulse") {
          orbs.forEach(other => {
            if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 100) {
              let damage = 15 * orb.crowdControl;
              if (other.flagShieldActive && other.flagShieldTimer > 0 && other.flagShieldCooldown <= 0) {
                let blocked = p.min(damage, 10);
                damage -= blocked;
                other.flagShieldActive = false;
                other.flagShieldCooldown = 200;
                createParticle(other, '#00f', 10, 30, true);
              } else if (other.shieldActive) {
                let blocked = p.min(damage, 10);
                damage -= blocked;
                other.shieldActive = false;
                createParticle(other, '#00f', 10, 30, true);
              }
              other.health = p.max(0, p.round(other.health - damage));
              other.shakeTimer = 10;
              other.shakeMagnitude = 3;
              other.swordSlash = { angle: p.random(0, p.TWO_PI), timer: 15, size: 25 };
              createParticle(other, '#ff4500', 8, 30, true);
              triggerCameraShake(5, 12);
            }
          });
        } else if (orb.auraEffect === "Scape") {
          orb.x += p.random(-120, 120);
          orb.y += p.random(-120, 120);
          orb.x = p.constrain(orb.x, orb.radius, p.width - orb.radius);
          orb.y = p.constrain(orb.y, orb.radius, p.height - orb.radius);
          createParticle(orb, '#ffffff', 10, 40, true);
          triggerCameraShake(4, 10);
        } else if (orb.auraEffect === "Overcharge") {
          let target = findNearestEnemy(orb);
          if (target) {
            projectiles.push({
              x: orb.x,
              y: orb.y,
              target,
              orb,
              damage: orb.attack * 3,
              color: '#ff0000',
              rgb: [255, 0, 0],
              size: 8,
              lifetime: 50,
              alpha: 255,
              vx: (target.x - orb.x) / 25,
              vy: (target.y - orb.y) / 25,
              beamTimer: 20
            });
            createParticle(orb, '#ff0000', 12, 50, true);
            triggerCameraShake(6, 14);
            triggerFlashEffect();
          }
        } else if (orb.auraEffect === "Absorb") {
          let target = findNearestEnemy(orb);
          if (target) {
            projectiles.push({
              x: orb.x,
              y: orb.y,
              target,
              orb,
              damage: orb.attack * 1.5,
              color: orb.coreColor,
              rgb: orb.coreRgb,
              size: 8,
              lifetime: 40,
              alpha: 255,
              vx: (target.x - orb.x) / 20,
              vy: (target.y - orb.y) / 20
            });
            createParticle(orb, '#0f0', 8, 20, true);
          }
        } else if (orb.auraEffect === "Stealth") {
          orb.skillScale = 0.5;
          setTimeout(() => orb.skillScale = 1.5, 1200);
          createParticle(orb, '#ffffff', 6, 20, true);
        } else if (orb.auraEffect === "Buff") {
          orbs.forEach(other => {
            if (other !== orb && other.health > 0 && p.dist(orb.x, orb.y, other.x, other.y) < 80) {
              other.attack += 5;
              createParticle(other, '#00ff00', 6, 20);
            }
          });
        }
        if (orb.specialModifier === "Aura Charge") {
          orb.chargeActive = true;
        } else if (orb.specialModifier === "Game Master Mark") {
          orb.gmmActive = true;
          setTimeout(() => orb.gmmActive = false, 1500);
          triggerCameraShake(5, 12);
        }
      }

      function attack(orb) {
        if (orb.health <= 0) return;
        let target = findNearestEnemy(orb);
        if (!target || p.dist(orb.x, orb.y, target.x, target.y) > orb.attackRange) return;
        let attack = orb.attack;
        if (orb.chargeActive) attack += 7;
        if (orb.gmmActive) attack *= 1.2;
        if (orb.rallyTimer > 0 && orb.hasFlag) {
          if (orb.battleCry === "VAMOS!") attack *= 1.1; // Argentina
          if (orb.battleCry === "SKÅL!") attack *= 1.15; // Norway
        }
        let hitChance = 1 - target.evasion - orb.crowdControl;
        if (orb.gmmActive) hitChance -= 0.1;
        if (orb.rallyTimer > 0 && orb.battleCry === "MAJID!") hitChance -= 0.1; // Qatar
        if (p.random() > hitChance) {
          createParticle(target, '#ffffff', 4, 15);
          if (target.role === "Dodging") {
            target.x += p.random(-30, 30);
            target.y += p.random(-30, 30);
            target.x = p.constrain(target.x, target.radius, p.width - target.radius);
            target.y = p.constrain(target.y, target.radius, p.height - target.radius);
            createParticle(target, '#ffffff', 6, 20, true);
          }
          return;
        }
        let damage = attack / (1 + target.defense / 10);
        if (orb.gmmActive) damage *= 1.2;
        if (orb.rallyTimer > 0 && orb.battleCry === "SKÅL!") damage *= 0.9; // Norway
        damage = p.max(0, p.round(damage));
        if (orb.role === "Long-Range") {
          projectiles.push({
            x: orb.x,
            y: orb.y,
            target,
            orb,
            damage,
            color: orb.coreColor,
            rgb: orb.coreRgb,
            size: 8,
            lifetime: 40,
            alpha: 255,
            vx: (target.x - orb.x) / 20,
            vy: (target.y - orb.y) / 20
          });
        } else {
          if (target.flagShieldActive && target.flagShieldTimer > 0 && target.flagShieldCooldown <= 0) {
            let blocked = p.min(damage, 10);
            damage -= blocked;
            target.flagShieldActive = false;
            target.flagShieldCooldown = 200;
            createParticle(target, '#00f', 10, 30, true);
            triggerCameraShake(3, 8);
          } else if (target.shieldActive) {
            let blocked = p.min(damage, 10);
            damage -= blocked;
            target.shieldActive = false;
            createParticle(target, '#00f', 10, 30, true);
            triggerCameraShake(3, 8);
          }
          if (orb.specialModifier === "Holographic Sheen") {
            let reflect = p.round(damage * 0.05);
            orb.health = p.max(0, orb.health - reflect);
            createParticle(orb, '#0ff', 6, 15);
          }
          target.health = p.max(0, p.round(target.health - damage));
          target.shakeTimer = 10;
          target.shakeMagnitude = damage / 4;
          target.swordSlash = { angle: p.atan2(target.y - orb.y, target.x - orb.x), timer: 15, size: 30 };
          orb.attackEffectTimer = 10;
          createParticle(target, '#f00', 10, 25, true);
          triggerCameraShake(4, 10);
          if (target.health <= 0) {
            createParticle(target, '#fff', 15, 50, true);
            triggerCameraShake(6, 12);
            if (orb.xpGain > 0) {
              orb.attack += orb.xpGain * 0.1;
            }
            checkGameOver();
          }
        }
        if (orb.chargeActive) orb.chargeActive = false;
        updateOrbStats();
      }

      function createParticle(orb, color, size, lifetime, burst = false) {
        color = color || '#00B7EB';
        const rgb = hexToRgb(color);
        const particleCount = burst ? 50 : 1;
        if (orbs.length > 100) return;
        for (let i = 0; i < particleCount; i++) {
          particles.push({
            x: orb.x,
            y: orb.y,
            vx: p.random(-5, 5),
            vy: p.random(-5, 5),
            size: p.random(size / 2, size),
            color,
            rgb,
            alpha: 255,
            lifetime: lifetime * p.random(0.8, 1.2),
            fadeRate: p.random(6, 12)
          });
        }
      }

      function drawOrb(orb) {
        try {
          p.push();
          let x = orb.x;
          let y = orb.y;
          if (orb.shakeTimer > 0) {
            x += p.random(-orb.shakeMagnitude, orb.shakeMagnitude);
            y += p.random(-orb.shakeMagnitude, orb.shakeMagnitude);
            orb.shakeTimer--;
          }
          p.translate(x, y);
          p.rotate(orb.rotation * (orb.role === "Dodging" ? 0.03 : 0.015));
          orb.trail.forEach((pos, i) => {
            p.fill(p.color(...validateRgb(orb.coreRgb), pos.alpha * (orb.auraEffect === "Stealth" ? 0.3 : 1)));
            p.noStroke();
            p.ellipse(pos.x - x, pos.y - y, orb.radius * (0.5 + i / 20) * orb.skillScale, orb.radius * (0.5 + i / 20) * orb.skillScale * 0.7);
            pos.alpha -= 8;
          });
          let pulse = p.sin(p.frameCount * 0.15) * 0.5 + 0.5;
          if (orb.hasFlag) {
            p.fill(p.color(255, 255, 255, 50 * pulse));
            p.noStroke();
            p.ellipse(0, 0, orb.radius * 5 * (orb.spawnProgress * pulse + 0.5) * orb.skillScale, orb.radius * 4 * (orb.spawnProgress * pulse + 0.5) * orb.skillScale);
          }
          p.fill(p.color(...validateRgb(orb.coreRgb), 80 * pulse * (orb.auraEffect === "Stealth" ? 0.4 : 1)));
          p.noStroke();
          p.ellipse(0, 0, orb.radius * 4 * (orb.spawnProgress * pulse + 0.5) * orb.skillScale, orb.radius * 3 * (orb.spawnProgress * pulse + 0.5) * orb.skillScale);
          let scale = p.lerp(0, 1, orb.spawnProgress);
          orb.spawnProgress = p.min(1, orb.spawnProgress + 0.05);
          p.scale(scale * orb.skillScale);
          if (orb.image) {
            p.image(orb.image, -orb.radius, -orb.radius, orb.radius * 2, orb.radius * 2);
          } else {
            p.fill(p.color(...validateRgb(orb.coreRgb), orb.auraEffect === "Stealth" ? 100 : 255));
            if (orb.skin === "Holographic") {
              p.stroke(255, 255, 255, p.random(100, 255));
              p.strokeWeight(3);
              createParticle(orb, '#fff', 3, 15);
            } else if (orb.skin === "Nebula") {
              p.stroke(...validateRgb(orb.coreRgb), 150);
              p.strokeWeight(5);
              createParticle(orb, orb.coreColor, 4, 20);
            } else if (orb.skin === "Crystal") {
              p.stroke(255, 255, 255, 200);
              p.strokeWeight(2);
            } else {
              p.noStroke();
            }
            p.ellipse(0, 0, orb.radius * 2, orb.radius * 2);
            p.fill(p.color(...validateRgb(orb.coreRgb), orb.auraEffect === "Stealth" ? 50 : 100));
            p.noStroke();
            p.ellipse(0, 0, orb.radius * 2.5, orb.radius * 2.5);
          }
          if (orb.swordSlash && orb.swordSlash.timer > 0) {
            p.push();
            p.rotate(orb.swordSlash.angle);
            p.stroke(255, 255, 255, 255 * (orb.swordSlash.timer / 15));
            p.strokeWeight(4);
            p.line(0, 0, orb.swordSlash.size, 0);
            p.stroke(...validateRgb(orb.coreRgb), 200 * (orb.swordSlash.timer / 15));
            p.line(0, 0, orb.swordSlash.size * 1.2, 0);
            p.fill(p.color(...validateRgb(orb.coreRgb), 150 * (orb.swordSlash.timer / 15)));
            p.noStroke();
            p.triangle(orb.swordSlash.size, 0, orb.swordSlash.size * 0.8, 5, orb.swordSlash.size * 0.8, -5);
            p.pop();
          }
          if (orb.attackEffectTimer > 0 && !orb.swordSlash) {
            p.push();
            p.rotate(p.random(0, p.TWO_PI));
            p.stroke(...validateRgb(orb.coreRgb), 200 * (orb.attackEffectTimer / 10));
            p.strokeWeight(3);
            p.line(0, 0, orb.radius * 1.5, 0);
            p.pop();
          }
          if (orb.effectTimer > 0) {
            orb.effectTimer--;
            if (orb.auraEffect === "Shield") {
              p.stroke(0, 0, 255, 220 * pulse);
              p.noFill();
              p.strokeWeight(6);
              p.ellipse(0, 0, orb.radius * 4 * orb.skillScale, orb.radius * 3.5 * orb.skillScale);
              createParticle(orb, '#00f', 8, 30);
            } else if (orb.auraEffect === "Surge") {
              p.stroke(0, 255, 255, 200 * pulse);
              p.strokeWeight(4);
              p.line(-orb.radius * 3, 0, orb.radius * 3, 0);
              p.line(0, -orb.radius * 3, 0, orb.radius * 3);
              createParticle(orb, '#0ff', 6, 25);
            } else if (orb.auraEffect === "Singularity") {
              p.fill(128, 0, 128, 140 * pulse);
              p.noStroke();
              p.ellipse(0, 0, orb.radius * 6 * orb.skillScale, orb.radius * 5 * orb.skillScale);
              createParticle(orb, '#800080', 10, 35, true);
            } else if (orb.auraEffect === "Pulse") {
              p.fill(255, 69, 0, 120 * pulse);
              p.noStroke();
              p.ellipse(0, 0, orb.radius * 5 * orb.skillScale, orb.radius * 4 * orb.skillScale);
              createParticle(orb, '#ff4500', 8, 30);
            }
          }
          if (orb.flagShieldActive && orb.flagShieldTimer > 0) {
            p.stroke(255, 215, 0, 220 * pulse);
            p.noFill();
            p.strokeWeight(6);
            p.ellipse(0, 0, orb.radius * 4.5 * orb.skillScale, orb.radius * 4 * orb.skillScale);
            createParticle(orb, '#FFD700', 8, 30);
          }
          p.pop();
        } catch (e) {
          console.error(`Error drawing ${orb.name}: ${e.message}`);
        }
      }

   
      function drawOrbLabels(orb) {
        try {
          p.push();
          let x = orb.x;
          let y = orb.y;
          if (orb.shakeTimer > 0) {
            x += p.random(-orb.shakeMagnitude, orb.shakeMagnitude);
            y += p.random(-orb.shakeMagnitude, orb.shakeMagnitude);
          }
          p.translate(x, y);
          p.fill(255);
          p.textAlign(p.CENTER, p.CENTER);
          p.textSize(12);
          p.text(orb.name, 0, -orb.radius - 30);
          if (orb.battleCryTimer > 0 && orb.battleCry) {
            p.fill(255, 255, 255, 255 * (orb.battleCryTimer / 60));
            p.textSize(16);
            p.textStyle(p.BOLD);
            p.text(orb.battleCry, 0, -orb.radius - 50);
          }
          let healthBarWidth = 50;
          p.fill(255, 0, 0);
          p.rect(-healthBarWidth / 2, -orb.radius - 15, healthBarWidth, 5);
          p.fill(0, 255, 0);
          p.rect(-healthBarWidth / 2, -orb.radius - 15, healthBarWidth * (orb.health / orb.maxHealth), 5);
          p.pop();
        } catch (e) {
          console.error(`Error drawing labels for ${orb.name}: ${e.message}`);
        }
      }

      function updateOrbStats() {
        let statsDiv = document.getElementById('orb-stats');
        statsDiv.innerHTML = orbs.map(orb => `
          <div class="orb-info">
            <strong>${orb.name}</strong> (${orb.role})${orb.hasFlag ? ' [Flag Bearer]' : ''}<br>
            Health: ${p.round(orb.health)}/${p.round(orb.maxHealth)}, Attack: ${p.round(orb.attack)}, Defense: ${p.round(orb.defense)}, Speed: ${p.round(orb.speed, 1)}, Cooldown: ${p.round(orb.cooldown, 1)}s
          </div>
        `).join('');
      }

      async function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        const success = await loadOrbs();
        if (!success) {
          gameStarted = false;
          startGameTriggered = false;
          document.getElementById('orb-count').textContent = "Waiting for game start...";
        }
      }

      window.restartGame = async () => {
        console.log("Restarting game...");
        orbs = [];
        particles = [];
        projectiles = [];
        cameraShake = { timer: 0, magnitude: 0, x: 0, y: 0 };
        gameOver = false;
        await startGame();
      };
    };

    if (typeof p5 === 'undefined') {
      console.error('p5.js failed to load. Check CDN or internet connection.');
      document.getElementById('orb-count').textContent = "Error: p5.js failed to load";
      Swal.fire({
        title: 'Error',
        text: 'p5.js library failed to load. Please check your internet connection.',
        icon: 'error',
        background: '#1a1a1a',
        color: '#ffffff',
        confirmButtonColor: '#4a5568'
      });
    } else {
      new p5(sketch);
    }
  </script>
  <style>
    body {
      margin: 0;
      background: linear-gradient(to bottom, #1a1a1a, #2d3748);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      font-family: 'Arial', sans-serif;
    }
    canvas {
      border: 4px solid #4a5568;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
    }
    #info {
      width: 800px;
      max-width: 90%;
      margin-top: 1rem;
    }
    .orb-info {
      background: #4a5568;
      padding: 0.75rem;
      border-radius: 6px;
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="info" class="text-white">
    <div class="flex justify-between items-center mb-4">
      <h2 class="text-2xl font-bold">Aura Orb Arena</h2>
      <div>
        <span id="orb-count" class="mr-4">Waiting for game start...</span>
      </div>
    </div>
    <div id="orb-stats" class="grid grid-cols-1 md:grid-cols-2 gap-2"></div>
  </div>
</body>
</html>